<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Marc Guyer</title><link>//marc.guyer.me/posts/</link><description>Recent content in Posts on Marc Guyer</description><generator>Hugo</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 11 Dec 2025 11:48:47 -0500</lastBuildDate><atom:link href="//marc.guyer.me/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Building a PHP 8.4 Lambda Runtime: Performance Analysis</title><link>//marc.guyer.me/posts/php-84-lambda-runtime-performance/</link><pubDate>Mon, 24 Nov 2025 12:00:00 -0500</pubDate><guid>//marc.guyer.me/posts/php-84-lambda-runtime-performance/</guid><description>&lt;h2 id="why-build-your-own-runtime"&gt;Why Build Your Own Runtime?&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://bref.sh/"&gt;Bref&lt;/a&gt; is the most popular way to run PHP on AWS Lambda, and for good reasonâ€”it&amp;rsquo;s well-maintained and gets the job done. However, there are situations where building your own runtime makes sense: you need a specific PHP version before Bref supports it, you want particular extensions, or you simply prefer working with standard PHP patterns without additional abstractions.&lt;/p&gt;
&lt;p&gt;This post documents a fully functional PHP 8.4 runtime running on ARM64, complete with performance benchmarks. Consider it a clearly documented alternative to Bref for teams who want complete control over their PHP Lambda environment.&lt;/p&gt;</description></item><item><title>Improving Efficiency of AI-Powered Coding with TDD</title><link>//marc.guyer.me/posts/improving-efficiency-ai-powered-coding-tdd/</link><pubDate>Tue, 26 Aug 2025 14:49:41 -0400</pubDate><guid>//marc.guyer.me/posts/improving-efficiency-ai-powered-coding-tdd/</guid><description>&lt;p&gt;The rise of AI coding assistants has transformed how we write software, but to truly maximize their potential, we need to adapt our development practices. Test-Driven Development (TDD) emerges as a particularly powerful methodology when combined with AI tools, creating a push-pull approach that enhances both code quality and development speed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This post assumes familiarity with TDD principles. If you&amp;rsquo;re new to TDD, consider starting with these resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530"&gt;Test Driven Development (Kent Beck)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://martinfowler.com/bliki/TestDrivenDevelopment.html"&gt;Martin Fowler on TDD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://phptherightway.com/#testing"&gt;PHP: The Right Way - Testing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-perfect-partnership-ai-and-tdd"&gt;The Perfect Partnership: AI and TDD&lt;/h2&gt;
&lt;p&gt;AI coding tools excel at generating code from clear specifications, while TDD provides exactly that - a precise specification in the form of tests. This natural alignment creates several advantages:&lt;/p&gt;</description></item><item><title>Building Multi-Architecture AWS Lambda Functions with Bref PHP and PostgreSQL</title><link>//marc.guyer.me/posts/bref-php-pdo-postgresql-multi-architecture-example/</link><pubDate>Wed, 15 May 2024 12:00:00 -0400</pubDate><guid>//marc.guyer.me/posts/bref-php-pdo-postgresql-multi-architecture-example/</guid><description>&lt;h2 id="the-multi-architecture-challenge"&gt;The Multi-Architecture Challenge&lt;/h2&gt;
&lt;p&gt;With the rise of Apple Silicon (ARM64) and the continued use of Intel-based (x86_64) systems, developers face increasing challenges in creating applications that work seamlessly across both architectures. This is especially true for PHP developers working with AWS Lambda, where subtle differences can lead to frustrating issues.&lt;/p&gt;
&lt;h2 id="example-with-bref-php-runtime--pdo-postgresql-extension"&gt;Example with Bref PHP Runtime + PDO PostgreSQL Extension&lt;/h2&gt;
&lt;p&gt;To address these challenges, I&amp;rsquo;ve created a comprehensive example repository that demonstrates a working multi-architecture implementation of PHP Lambda functions using &lt;a href="https://bref.sh/"&gt;Bref&lt;/a&gt; and PDO PostgreSQL. This example focuses on:&lt;/p&gt;</description></item><item><title>Mezzio Example: Testing Doctrine Entities and Repositories</title><link>//marc.guyer.me/posts/mezzio-example/testing-doctrine-entities-and-repositories/</link><pubDate>Thu, 16 Sep 2021 16:25:49 -0500</pubDate><guid>//marc.guyer.me/posts/mezzio-example/testing-doctrine-entities-and-repositories/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;In this post, we&amp;rsquo;ll see how to create a comprehensive testing framework for Doctrine Entities and Repositories. This is a continuation of our &lt;a href="//marc.guyer.me/posts/mezzio-example/doctrine-entities-and-repositories/"&gt;Mezzio Example series&lt;/a&gt; where we previously created our domain model for an OAuth2-enabled application.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s make sure our Entities and Repositories have full test coverage. The domain model is a significant part of any dynamic application so the code should be in good shape. We don&amp;rsquo;t want any bugs here.&lt;/p&gt;</description></item><item><title>Mezzio Example: Doctrine Entities and Repositories</title><link>//marc.guyer.me/posts/mezzio-example/doctrine-entities-and-repositories/</link><pubDate>Wed, 15 Sep 2021 16:25:49 -0500</pubDate><guid>//marc.guyer.me/posts/mezzio-example/doctrine-entities-and-repositories/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;This post brings several pieces of supporting libraries together.&lt;/p&gt;
&lt;h3 id="entities-to-support-oauth2-requirements"&gt;Entities to Support OAuth2 Requirements&lt;/h3&gt;
&lt;p&gt;We&amp;rsquo;ll start by defining a minimum domain model via PHP8 Attributes and Doctrine&amp;rsquo;s new attribute mapping driver. In the short-term, we only need to model what&amp;rsquo;s necessary for our application&amp;rsquo;s authentication layer using OAuth2. For now, we&amp;rsquo;re creating a minimal set of objects to comply with the needs of our supporting libraries&amp;rsquo; interfaces. We need a minimum of 6 entities and their corresponding repositories:&lt;/p&gt;</description></item><item><title>Mezzio Example: Psalm Introduction</title><link>//marc.guyer.me/posts/mezzio-example/psalm-introduction/</link><pubDate>Wed, 15 Sep 2021 14:28:49 -0500</pubDate><guid>//marc.guyer.me/posts/mezzio-example/psalm-introduction/</guid><description>&lt;h2 id="what-is-psalm"&gt;What is Psalm?&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://psalm.dev"&gt;Psalm&lt;/a&gt; is a static analysis tool for PHP that helps you identify problems with your code. If you use it, you&amp;rsquo;ll become a better coder. I promise.&lt;/p&gt;
&lt;h3 id="learn-more-about-psalm"&gt;Learn more about Psalm&lt;/h3&gt;
&lt;p&gt;Here&amp;rsquo;s a great read &amp;ndash; the story of the origins of Psalm at Vimeo and the value it provided the team.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://psalm.dev/articles/fixing-code-that-aint-broken"&gt;https://psalm.dev/articles/fixing-code-that-aint-broken&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this post, I&amp;rsquo;ll show a basic setup for static analysis with Psalm in Mezzio applications.&lt;/p&gt;</description></item><item><title>Mezzio Example: Functional and Unit Testing</title><link>//marc.guyer.me/posts/mezzio-example/functional-and-unit-testing/</link><pubDate>Sun, 01 Dec 2019 14:28:49 -0500</pubDate><guid>//marc.guyer.me/posts/mezzio-example/functional-and-unit-testing/</guid><description>&lt;h2 id="where-do-we-start"&gt;Where do we start?&lt;/h2&gt;
&lt;p&gt;It&amp;rsquo;s a good choice to start any application with a solid structure for testing the application with automated testing tools. That&amp;rsquo;s why the first post in this series is about testing. Any well-tested application will typically have more lines of testing code than actual application code. Starting with a good structure for testing will pay dividends down the road.&lt;/p&gt;
&lt;p&gt;In this post, I&amp;rsquo;ll show a basic setup for testing Mezzio applications. We&amp;rsquo;ll get to some more advanced testing topics in later posts.&lt;/p&gt;</description></item><item><title>Mezzio Example: Introduction</title><link>//marc.guyer.me/posts/mezzio-example/introduction/</link><pubDate>Mon, 04 Nov 2019 15:08:36 -0400</pubDate><guid>//marc.guyer.me/posts/mezzio-example/introduction/</guid><description>&lt;h2 id="what-is-this"&gt;What is this?&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s create a REST API with &lt;a href="https://docs.mezzio.dev/"&gt;Mezzio&lt;/a&gt;. In this series, you&amp;rsquo;ll learn how to create a REST API from the ground up. We&amp;rsquo;ll use Mezzio as the base framework, Doctrine for the data layer, OAuth2 for authentication and authorization, PHPUnit for automated testing, and several other libraries along the way.&lt;/p&gt;
&lt;h2 id="source-code"&gt;Source Code&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve created a new bare-bones application starting with the &lt;a href="https://github.com/mezzio/mezzio-skeleton"&gt;Mezzio Skeleton Application&lt;/a&gt; where all the code shown in this series lives. You can install it in your local environment and hack on it all you want. You&amp;rsquo;re also welcome to contribute to the example application via PR. Check it out here:&lt;/p&gt;</description></item><item><title>Example Recovery Procedure for MySQL Backup Made with Xtrabackup</title><link>//marc.guyer.me/posts/example-recovery-procedure-for-mysql-backup-made-with-xtrabackup/</link><pubDate>Tue, 24 Sep 2019 17:09:56 -0400</pubDate><guid>//marc.guyer.me/posts/example-recovery-procedure-for-mysql-backup-made-with-xtrabackup/</guid><description>&lt;p&gt;We have a pre-existing procedure for backing up a MySQL database using hot backups with the wonderful &lt;a href="https://www.percona.com/doc/percona-xtrabackup/2.4/index.html"&gt;Percona Xtrabackup&lt;/a&gt; and in this case the deprecated &lt;a href="https://www.percona.com/doc/percona-xtrabackup/2.4/innobackupex/innobackupex_option_reference.html"&gt;innobackupex&lt;/a&gt; binary.&lt;/p&gt;
&lt;p&gt;Xtrabackup is nice since it creates a clean backup of InnoDB, XtraDB, and MyISAM tables quickly and &lt;em&gt;without locking&lt;/em&gt;. There are countless useful features including point-in-time recovery, incremental backups, single table recovery, single partition recovery, I/O throttling, parallel processing, encryption, compression, streaming, and more.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A basic recovery procedure document was needed so I wrote one. Here is is.&lt;/strong&gt;&lt;/p&gt;</description></item></channel></rss>